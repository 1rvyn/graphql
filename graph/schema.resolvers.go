package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.35

import (
	"context"
	"errors"
	"fmt"
	"log"
	"net"
	"net/smtp"
	"strconv"
	"time"

	"github.com/1rvyn/graphql-service/database"
	"github.com/1rvyn/graphql-service/graph/model"
	"github.com/1rvyn/graphql-service/models"
	"github.com/1rvyn/graphql-service/utils"
	"gorm.io/gorm"
)

// CreateEmployee is the resolver for the createEmployee field.
func (r *mutationResolver) CreateEmployee(ctx context.Context, input model.NewEmployee) (*model.Employee, error) {
	// Convert dob from string to time.Time
	dob, err := time.Parse("2006-01-02", input.Dob)
	if err != nil {
		return nil, err
	}

	// Convert departmentID from string to uint
	departmentID, err := strconv.Atoi(input.DepartmentID)
	if err != nil {
		return nil, err
	}

	// Check if an employee with the same username or email already exists
	var existingEmployee models.Employee
	result := database.Database.Db.Where("username = ? OR email = ?", input.Username, input.Email).First(&existingEmployee)
	if result.Error != nil {
		if !errors.Is(result.Error, gorm.ErrRecordNotFound) {
			// An unexpected error occurred
			return nil, result.Error
		}
		// No employee with the same username or email exists, continue to create the new employee
	} else {
		// An employee with the same username or email already exists
		return nil, fmt.Errorf("an employee with the same username or email already exists")
	}

	employee := &models.Employee{
		FirstName:    input.FirstName,
		LastName:     input.LastName,
		Username:     input.Username,
		Password:     utils.HashPassword(input.Password), // special JUICE (isnt this super clean?)
		Email:        input.Email,
		DOB:          dob,
		DepartmentID: uint(departmentID),
		Position:     input.Position,
	}

	if err := database.Database.Db.Create(employee).Error; err != nil {
		return nil, err
	}

	// Connect to the SMTP server.
	conn, err := net.Dial("tcp", "mail:1025")
	if err != nil {
		log.Println("Failed to connect to mail server:", err)
		return nil, err
	}

	// Create a new unencrypted SMTP client.
	c, err := smtp.NewClient(conn, "mail")
	if err != nil {
		log.Println("Failed to create SMTP client:", err)
		return nil, err
	}

	// Set the sender and recipient.
	if err := c.Mail("testing@takehomesecuri.com"); err != nil {
		log.Println("Failed to set mail sender:", err)
		return nil, err
	}
	if err := c.Rcpt(employee.Email); err != nil {
		log.Println("Failed to set mail recipient:", err)
		return nil, err
	}

	// Send the email body.
	wc, err := c.Data()
	if err != nil {
		log.Println("Failed to get mail data writer:", err)
		return nil, err
	}
	_, err = fmt.Fprintf(wc, "Welcome to the company!")
	if err != nil {
		log.Println("Failed to write mail data:", err)
		return nil, err
	}
	err = wc.Close()
	if err != nil {
		log.Println("Failed to close mail data writer:", err)
		return nil, err
	}

	// Close the SMTP connection.
	err = c.Quit()
	if err != nil {
		log.Println("Failed to close SMTP connection:", err)
		return nil, err
	}

	// Convert models.Employee to model.Employee before returning
	return &model.Employee{
		ID:           strconv.Itoa(int(employee.ID)),
		FirstName:    employee.FirstName,
		LastName:     employee.LastName,
		Username:     employee.Username,
		Password:     string(employee.Password),
		Email:        employee.Email,
		Dob:          employee.DOB.Format("2006-01-02"),
		DepartmentID: strconv.Itoa(int(employee.DepartmentID)),
		Position:     employee.Position,
		CreatedAt:    employee.CreatedAt.Format(time.RFC3339),
		UpdatedAt:    employee.UpdatedAt.Format(time.RFC3339),
	}, nil
}

// UpdateEmployee is the resolver for the updateEmployee field.
func (r *mutationResolver) UpdateEmployee(ctx context.Context, id string, input model.UpdateEmployee) (*model.Employee, error) {
	// Convert id from string to uint
	employeeID, err := strconv.Atoi(id)
	if err != nil {
		return nil, err
	}

	// Find the employee to be updated
	var employee models.Employee
	if err := database.Database.Db.First(&employee, employeeID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, fmt.Errorf("employee not found")
		}
		return nil, err
	}

	// Update the fields if they are set
	if input.FirstName != nil {
		employee.FirstName = *input.FirstName
	}
	if input.LastName != nil {
		employee.LastName = *input.LastName
	}
	if input.Username != nil {
		employee.Username = *input.Username
	}
	if input.Password != nil {
		employee.Password = utils.HashPassword(*input.Password) // hash the password before storing
	}
	if input.Email != nil {
		employee.Email = *input.Email
	}
	if input.Dob != nil {
		dob, err := time.Parse("2006-01-02", *input.Dob)
		if err != nil {
			return nil, err
		}
		employee.DOB = dob
	}
	if input.DepartmentID != nil {
		departmentID, err := strconv.Atoi(*input.DepartmentID)
		if err != nil {
			return nil, err
		}
		employee.DepartmentID = uint(departmentID)
	}
	if input.Position != nil {
		employee.Position = *input.Position
	}

	// Save the updated employee to the database
	if err := database.Database.Db.Save(&employee).Error; err != nil {
		return nil, err
	}

	// Convert models.Employee to model.Employee before returning
	return &model.Employee{
		ID:           strconv.Itoa(int(employee.ID)),
		FirstName:    employee.FirstName,
		LastName:     employee.LastName,
		Username:     employee.Username,
		Password:     string(employee.Password),
		Email:        employee.Email,
		Dob:          employee.DOB.Format("2006-01-02"),
		DepartmentID: strconv.Itoa(int(employee.DepartmentID)),
		Position:     employee.Position,
		CreatedAt:    employee.CreatedAt.Format(time.RFC3339),
		UpdatedAt:    employee.UpdatedAt.Format(time.RFC3339),
	}, nil
}

// DeleteEmployee is the resolver for the deleteEmployee field.
func (r *mutationResolver) DeleteEmployee(ctx context.Context, id string) (*bool, error) {
	// Convert id from string to uint
	employeeID, err := strconv.Atoi(id)
	if err != nil {
		return nil, err
	}

	// Find the employee to be deleted
	var employee models.Employee
	if err := database.Database.Db.First(&employee, employeeID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, fmt.Errorf("employee not found")
		}
		return nil, err
	}

	// Delete the employee from the database
	if err := database.Database.Db.Delete(&employee).Error; err != nil {
		return nil, err
	}

	// Return true if the deletion was successful
	result := true
	return &result, nil
}

// Employees is the resolver for the employees field.
func (r *queryResolver) Employees(ctx context.Context, filter *model.EmployeeFilter, sort *model.EmployeeSort, pagination *model.Pagination) ([]*model.Employee, error) {
	var employees []*models.Employee
	db := database.Database.Db

	// Apply the filter parameters to the database query
	if filter != nil {
		if filter.FirstName != nil {
			db = db.Where("first_name = ?", *filter.FirstName)
		}
		if filter.LastName != nil {
			db = db.Where("last_name = ?", *filter.LastName)
		}
		if filter.Dob != nil {
			dob, err := time.Parse("2006-01-02", *filter.Dob)
			if err != nil {
				return nil, err
			}
			db = db.Where("dob = ?", dob)
		}
		// Add more filter conditions here...
	}

	// Apply sorting
	if sort != nil {
		if sort.CreatedAt != nil {
			order := "ASC"
			if *sort.CreatedAt == model.SortDirectionDesc { // Corrected
				order = "DESC"
			}
			db = db.Order("created_at " + order) // Adjust this line
		}
	}

	if pagination != nil {
		pageNumber := *pagination.PageNumber
		pageSize := *pagination.PageSize

		if pageNumber < 1 {
			pageNumber = 1
		}
		if pageSize < 1 {
			pageSize = 10 // Default page size
		}
		// Apply the pagination parameters to the database query
		db = db.Offset((pageNumber - 1) * pageSize).Limit(pageSize)
	}

	result := db.Find(&employees)
	if result.Error != nil {
		return nil, result.Error
	}

	var modelEmployees []*model.Employee
	for _, employee := range employees {
		modelEmployees = append(modelEmployees, &model.Employee{
			ID:           strconv.Itoa(int(employee.ID)),
			FirstName:    employee.FirstName,
			LastName:     employee.LastName,
			Username:     employee.Username,
			Password:     string(employee.Password),
			Email:        employee.Email,
			Dob:          employee.DOB.Format("2006-01-02"),
			DepartmentID: strconv.Itoa(int(employee.DepartmentID)),
			Position:     employee.Position,
			CreatedAt:    employee.CreatedAt.Format(time.RFC3339),
			UpdatedAt:    employee.UpdatedAt.Format(time.RFC3339),
		})
	}

	return modelEmployees, nil
}

// Employee is the resolver for the employee field.
func (r *queryResolver) Employee(ctx context.Context, id string) (*model.Employee, error) {
	// Parse the ID to uint
	employeeID, err := strconv.ParseUint(id, 10, 32)
	if err != nil {
		return nil, err
	}

	// Fetch the employee from the database
	var employee models.Employee
	result := database.Database.Db.First(&employee, uint(employeeID))
	if result.Error != nil {
		return nil, result.Error
	}

	// Convert models.Employee to model.Employee before returning
	return &model.Employee{
		ID:           strconv.Itoa(int(employee.ID)),
		FirstName:    employee.FirstName,
		LastName:     employee.LastName,
		Username:     employee.Username,
		Password:     string(employee.Password),
		Email:        employee.Email,
		Dob:          employee.DOB.Format("2006-01-02"),
		DepartmentID: strconv.Itoa(int(employee.DepartmentID)),
		Position:     employee.Position,
		CreatedAt:    employee.CreatedAt.Format(time.RFC3339),
		UpdatedAt:    employee.UpdatedAt.Format(time.RFC3339),
	}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
